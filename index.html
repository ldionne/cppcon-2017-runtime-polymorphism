<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Runtime Polymorphism: Back to the Basics</title>
    <meta name="author" content="Louis Dionne">

    <link rel="stylesheet" href="reveal/css/reveal.css">
    <link rel="stylesheet" href="reveal/css/theme/black.css">
    <link rel="stylesheet" href="custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="highlight-styles/monokai-sublime.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown=""
                 data-separator="^====+$"
                 data-separator-vertical="^----+$"
                 data-notes="^Note:">
        <script type="text/template">

## Runtime Polymorphism:<br>Back to the Basics
#### Louis Dionne, CppCon 2017

<!--
TODO:
- Consider using `function_ref`, `std::function`, and `inplace_function` as
  guinea pigs. This would give much better real world examples than `Vehicle`.
- Present an example where pulling the vtable down allows devirtualizing what
  could not normally be devirtualized by the compiler.
- We need to present benchmarks against classic inheritance
- We need to present benchmarks against variant too
-->

==============================================================================

### What is runtime polymorphism <br> and when do you need it?

----

### Assume the following

```c++
struct Car {
  void accelerate();
};

struct Truck {
  void accelerate();
};

struct Plane {
  void accelerate();
};
```

----

### Returning related types from a function

```c++
??? getVehicle(std::istream& user) {
  std::string choice;
  user >> choice;
  if      (choice == "car")   return Car{...};
  else if (choice == "truck") return Truck{...};
  else if (choice == "plane") return Plane{...};
  else                        die();
}
```

----

### Storing related types in a container

```c++
int main() {
  // Should store anything that has an accelerate() method
  std::vector<???> vehicles;

  vehicles.push_back(Car{...});
  vehicles.push_back(Truck{...});
  vehicles.push_back(Plane{...});

  for (auto& vehicle : vehicles) {
    vehicle.accelerate();
  }
}
```

----

### `variant` sometimes does the trick

- But it only works for closed set of types
- Using visitation is sometimes (often?) not convenient

----

### Bottom line:
#### Manipulating an open set of related types with different representations

====================

### C++ has a solution for that!

----

### Inheritance

<pre><code data-sample="code/inheritance.cpp#Vehicle"></code></pre>

----

### Usage

<pre><code data-sample="code/inheritance.cpp#main"></code></pre>

----

### Under the hood

![Implementation of inheritance](img/inheritance.png)

====================

### Aside
#### Inheritance has many problems

----

### Bakes in reference semantics

```c++
void foo(Vehicle* vehicle) {
  ...
  vehicle->accelerate();
  ...
}
```

or

```c++
void foo(Vehicle& vehicle) {
  ...
  vehicle.accelerate();
  ...
}
```

----

### Slices when you try to be clever

```c++
void foo(Vehicle vehicle) {
  ...
  vehicle.accelerate();
  ...
}
```

----

### Heap allocations

```c++
std::unique_ptr<Vehicle> getVehicle(std::istream& user) {
  std::string choice;
  user >> choice;
  if      (choice == "car")   return std::make_unique<Car>(...);
  else if (choice == "truck") return std::make_unique<Truck>(...);
  else if (choice == "plane") return std::make_unique<Plane>(...);
  else                        die();
}
```

----

### Bakes in nullable semantics

```c++
std::unique_ptr<Vehicle> vehicle = getVehicle(std::cin);
// can vehicle be null?
```

----

### Ownership hell

```c++
Vehicle*                 getVehicle(std::istream& user);
std::unique_ptr<Vehicle> getVehicle(std::istream& user);
std::shared_ptr<Vehicle> getVehicle(std::istream& user);
```

----

### No value semantics

```c++
std::vector<std::unique_ptr<Vehicle>> vehicles;
vehicles.push_back(std::make_unique<Car>(...));
vehicles.push_back(std::make_unique<Truck>(...));
vehicles.push_back(std::make_unique<Plane>(...));

std::vector<std::unique_ptr<Vehicle>> copy = vehicles;
for (auto& vehicle : copy) {
  vehicle->accelerate();
}
```

----

### Doesn't play well with algorithms

```c++
std::vector<std::unique_ptr<Vehicle>> vehicles;
vehicles.push_back(std::make_unique<Car>(...));
vehicles.push_back(std::make_unique<Truck>(...));
vehicles.push_back(std::make_unique<Plane>(...));

std::sort(vehicles.begin(), vehicles.end()); // NOT what you wanted!
```

----

### Intrusive

```c++
namespace lib {
  struct Motorcycle { void accelerate(); };
}

void foo(Vehicle& vehicle) {
  ...
  vehicle.accelerate();
  ...
}

Motorcycle bike;
foo(bike); // can't work!
```

----

### Listen to Sean Parent, not me
https://youtu.be/QGcVXgEVMJg

====================

### I just wanted this!

```c++
interface Vehicle { void accelerate(); };

namespace lib {
  struct Motorcycle { void accelerate(); };
}
struct Car   { void accelerate(); };
struct Truck { void accelerate(); };

int main() {
  std::vector<Vehicle> vehicles;
  vehicles.push_back(Car{...});
  vehicles.push_back(Truck{...});
  vehicles.push_back(lib::Motorcycle{...});

  for (auto& vehicle : vehicles) {
    vehicle.accelerate();
  }
}
```

----

### How might that work?

----

### Goal:
#### Independent storage and method dispatch

- Storage _policy_
- VTable _policy_

Note:
State motivation for the talk, i.e. we're going to play around with different
ways of implementing the `interface` keyword shown above.

====================

### Remote storage

![Naive type erasure with a fat pointer](img/remote_storage.png)

----

### How that's implemented

<pre><code data-sample='code/remote_storage.cpp#Vehicle'></code></pre>

Note:
Quickly show a preview of the vtable, and then come back to explain.

----

### The vtable

<pre><code data-sample='code/vtable.hpp#vtable'></code></pre>

----

### With Dyno

<pre><code data-sample='code/remote_storage.dyno.cpp#Vehicle'></code></pre>

Note:
Explain that this is a compile-time string, and it's as efficient as a
member access in a struct (the vtable).

----

### Dyno's vtable

<pre><code data-sample='code/vtable.dyno.hpp#IVehicle'></code></pre>

----

### Strengths and weaknesses

<ul>
  <li class="strength">Simple model, similar to classic inheritance</li>
  <li class="weakness">Always requires an allocation</li>
</ul>

====================

### The _small buffer optimization_ (SBO)

![Type erasure with SBO](img/sbo_storage.png)

----

### How that's implemented

<pre><code data-sample='code/sbo_storage.cpp#Vehicle::members'></code></pre>

----

### Construction

<pre><code data-sample='code/sbo_storage.cpp#Vehicle::Vehicle'></code></pre>

Note:
Make sure to explain placement new.

----

### Destruction

<pre><code data-sample='code/sbo_storage.cpp#Vehicle::~Vehicle'></code></pre>

----

### Method dispatching

<pre><code data-sample='code/sbo_storage.cpp#Vehicle::accelerate'></code></pre>

----

### Alternative implementation 1

![Type erasure with SBO, alternative implementation 1](img/sbo_storage-alternative1.png)

Note:
We can actually inline the bool into the vtable's function definitions, since
they always know whether the thing is going to be in the buffer or on the heap.

----

### Alternative implementation 2
(seems to be the fastest)

![Type erasure with SBO, alternative implementation 2](img/sbo_storage-alternative2.png)

----

### Simple generalization

![Type erasure with SBO and parameterized buffer size](img/sbo_storage-generalized.png)

----

### With Dyno

<pre><code data-sample='code/sbo_storage.dyno.cpp#Vehicle'></code></pre>

----

### Strengths and weaknesses

<ul>
  <li class="strength">Does not always require allocating</li>
  <li class="weakness">Takes up more space</li>
  <li class="weakness">Copy/move/swap is more complicated</li>
  <li class="weakness">Dispatching may be more costly</li>
</ul>

Note:
We need to handle cases where the two types are not the same in swap.

====================

### Always-local storage

![Type erasure with local storage](img/local_storage.png)

----

### Doesn't fit? Doesn't compile!

----

### How that's implemented

<pre><code data-sample='code/local_storage.cpp#Vehicle'></code></pre>

----

### With Dyno

<pre><code data-sample='code/local_storage.dyno.cpp#Vehicle'></code></pre>

----

### Strengths and weaknesses

<ul>
  <li class="strength">No allocation &ndash; ever</li>
  <li class="strength">Simple dispatching</li>
  <li class="weakness">Takes up more space</li>
</ul>

====================

### Some benchmarks

Creating many 4 bytes objects
<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [80]
      }
    },
    "hAxis": { "title": "Storage type" }
  },
  "data": [
    ["Storage type", "Time (ns)"],
    ["remote storage", 54],
    ["SBO storage (4 bytes)", 2],
    ["SBO storage (8 bytes)", 2],
    ["SBO storage (16 bytes)", 2],
    ["local storage (16 bytes)", 2]
  ]
}
</div>

----

Creating many 16 bytes objects
<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [80]
      }
    },
    "hAxis": { "title": "Storage type" }
  },
  "data": [
    ["Storage type", "Time (ns)"],
    ["remote storage", 54],
    ["SBO storage (4 bytes)", 54],
    ["SBO storage (8 bytes)", 54],
    ["SBO storage (16 bytes)", 2],
    ["local storage (16 bytes)", 2]
  ]
}
</div>

----

Accessing many 4 bytes objects<br>
(10 x 3 method calls, SBO with bool)

<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [80]
      }
    },
    "hAxis": { "title": "Storage type" }
  },
  "data": [
    ["Storage type", "Time (ns)"],
    ["remote storage", 46],
    ["SBO storage (4 bytes)", 59],
    ["SBO storage (8 bytes)", 59],
    ["SBO storage (16 bytes)", 59],
    ["local storage (16 bytes)", 47]
  ]
}
</div>

----

<!-- .slide: class="slide-hidden" -->

Accessing many objects<br>
(half 8 bytes, half 16 bytes, SBO with bool)
<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [80]
      }
    },
    "hAxis": { "title": "Storage type" }
  },
  "data": [
    ["Storage type", "Time (ns)"],
    ["remote storage", 46],
    ["SBO storage (4 bytes)", 55],
    ["SBO storage (8 bytes)", 57],
    ["SBO storage (16 bytes)", 57],
    ["local storage (16 bytes)", 46]
  ]
}
</div>

----

Accessing many 4 bytes objects
<br>(10 x 3 method calls, SBO with pointer)
<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [80]
      }
    },
    "hAxis": { "title": "Storage type" }
  },
  "data": [
    ["Storage type", "Time (ns)"],
    ["remote storage", 47],
    ["SBO storage (4 bytes)", 46],
    ["SBO storage (8 bytes)", 46],
    ["SBO storage (16 bytes)", 46],
    ["local storage (16 bytes)", 47]
  ]
}
</div>

----

<!-- .slide: class="slide-hidden" -->

Accessing many objects<br>
(half 8 bytes, half 16 bytes, SBO with pointer)
<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [80]
      }
    },
    "hAxis": { "title": "Storage type" }
  },
  "data": [
    ["Storage type", "Time (ns)"],
    ["remote storage", 48],
    ["SBO storage (4 bytes)", 47],
    ["SBO storage (8 bytes)", 47],
    ["SBO storage (16 bytes)", 48],
    ["local storage (16 bytes)", 48]
  ]
}
</div>

----

### Guidelines

- Use local storage whenever you can afford it
- When space is very important, use remote storage
- Otherwise, use SBO with the largest size you can afford (depending on your problem)

====================

### Non-owning storage
(reference semantics, not value semantics)

----

### Basically a polymorphic view

```c++
void process(VehicleRef vehicle) {
  ...
  vehicle.accelerate();
  ...
}

int main() {
  Truck truck{...};
  process(truck); // Don't want to copy here!
}
```

----

### In pictures

![Type erasure with non-owning storage](img/non_owning_storage.png)

----

### How that's implemented

<pre><code data-sample='code/non_owning_storage.cpp#VehicleRef'></code></pre>

----

### With Dyno

<pre><code data-sample='code/non_owning_storage.dyno.cpp#VehicleRef'></code></pre>

----

### Usage differs a bit

<pre><code data-sample='code/non_owning_storage.cpp#main'></code></pre>

====================

### Shared remote storage

![Type erasure with shared remote storage](img/shared_storage.png)

<!-- TODO: Show some use cases (e.g. Sean Parent's `document`) -->

----

### How that's implemented

<pre><code data-sample='code/shared_remote_storage.cpp#Vehicle'></code></pre>

==============================================================================

### What about vtables?

----

### Normally, it is remote

![Traditional fully remote vtable](img/remote_vtable.png)

----

### Turns out we have some choices

====================

### Inlining the vtable in the object

<img src="img/local_vtable.png" style="width:600px; height:auto;">

----

### How that's implemented

<pre><code data-sample='code/local_vtable.cpp#Vehicle'></code></pre>

----

### With Dyno

<pre><code data-sample='code/local_vtable.dyno.cpp#Vehicle'></code></pre>

----

### Usually a pessimization

====================

### Partial vtable inlining

![Partially inlined vtable](img/joined_vtable.png)

----

### The Vtable &mdash; remote part

<pre><code data-sample='code/joined_vtable.cpp#vtable'></code></pre>

----

### The Vtable &mdash; local part

<pre><code data-sample='code/joined_vtable.cpp#joined_vtable'></code></pre>

----

### The polymorphic wrapper

<pre><code data-sample='code/joined_vtable.cpp#Vehicle'></code></pre>

----

### With Dyno

<pre><code data-sample='code/joined_vtable.dyno.cpp#Vehicle'></code></pre>

====================

### Some benchmarks

Calling 2 virtual functions (100 x 2 calls)
<div class="google-chart">
{
  "options": {
    "legend": { "position": "none" },
    "vAxis": {
      "title": "Time (ns)",
      "viewWindow": {
        "min": [0],
        "max": [500]
      }
    },
    "hAxis": { "title": "VTable flavor" }
  },
  "data": [
    ["VTable flavor", "Time (ns)"],
    ["everything remote", 462],
    ["1 function local", 438],
    ["2 functions local", 487]
  ]
}
</div>

----

### Not very conclusive

----

### Let's look at assembly

<iframe class="stretch" src="https://gcc.godbolt.org/e#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSBnVAV2OUxAHIGDjnkCAagBqAFQCGAIwA2mQQFIA7ACF5ABgCCgwQDdUedIIgAqAGa0AlBD0HjF%2BQGZVm7TcMnTAJitu7j51q6%2Bu5mDj7Bfk7qgW5GZgAs4bb2UZpKACL%2B0dEEmAC2AA7S4rkKDgDCBACeBZgAduJ5cqKO2NGYAB65xHUiEjJyaHU8ugRSsllpUxo8fAKCxPmouQD64nVVCirRrsGC5hAWW8q6BbwrALStBwyY0qYrKScZO0EG%2B56Hx6fnVw7YXggt3uj38W0yLjehlMDi%2BShOOjOxEu11hwIeT3Br1ipnicJUP2RfwBePRoKcWMhYnGg1QwwIxkEQxGiPOkxiEUEZPZL1SGmis34QmkqGQ4mkaw2x2xewOR3hoxkKwAdDc7hiwS9ITjPvKCToCErVZ8yZitRz3jD8QjDRLVWj1eTnooIRboXi9TajbigY6zS7XtSBky6SzbSt2btbFzHTyA3yBbwhYI8HUEJhiIR1uxJZt4di8MQCMxxVD9rQ4Q50oI1JHdIXi6WdZXq7W%2Ba4GyXpGWrfKqzW6zpO03ZR6yq245kE5ocRBFnllphc/JPAA2QTiT2vcSqitPbfGw51ne94%2Bqj2T7Iz2UQEViiXrKor9eb6WQk97s%2BA/fv%2B1H9sbue/4BOa0Szqm6aZmMdQ5o%2Bz4bluv5yl%2BupfrCP6BCeF4JgGmicBYpDSFwACsnCkHUXBqGRqBcOUK6qJ4JxMKw7AKJ4Di0GRBCUfhBEANYgMRtDKgAnKuaiKAAHPEHEOIonjEcRhFcPEZEUZwVGkDRnBkQwIBqKQ3EafhpBwLASBoIUeCyGQFAQJZBTWRmKDFHUwDEWoBmmNZ3R6RAkg8aQkipuIxBVFwnGkJZTR1AQADydTSOFxmkFgeTrMAsiBfgiwCHgOiYHpKWdJgyDMLkEVkamuREZwkW8HgeSVaQzB1Fg3l1Jg6CVQR0h4JIemQARqBnHgoZcBccUOIIFw8OgjjpMg9H0bQqmMCwbAcJYymcKR5GBdpHSSauFyrvETKucAgjEcqai3UYuCECQbEcaQgjlKgVk2S9lhcTxFj8SA8SSbdDgiZ4tDEaux2eIo8RCTta3qZp2m6fphn/b1XCeGpB1cH9xkA6QBXEAwY0UfEQA%3D%3D"></iframe>

Note:
Chandler told me:
With the remote vtable, the vptr has to be reloaded every time because it
could have changed during the virtual call. When the function pointers are
in the object, the compiler can see they don't change.

----

### Guidelines

- By default, all methods are in the remote vtable
- Consider inlining some methods if
  - you have slack space
  - you know you're calling them often
  - you've measured it makes a difference

==============================================================================

### The future with reflection?

```c++
struct Vehicle {
  void accelerate();
};

int main() {
  std::vector<any<Vehicle>> vehicles;
  vehicles.push_back(Car{...});
  vehicles.push_back(Truck{...});
  vehicles.push_back(lib::Motorcycle{...});

  for (auto& vehicle : vehicles) {
    vehicle.accelerate();
  }
}
```

----

### The future with metaclasses?

```c++
interface Vehicle {
  void accelerate();
};

int main() {
  std::vector<Vehicle> vehicles;
  vehicles.push_back(Car{...});
  vehicles.push_back(Truck{...});
  vehicles.push_back(lib::Motorcycle{...});

  for (auto& vehicle : vehicles) {
    vehicle.accelerate();
  }
}
```

==============================================================================

### Summary

- Inheritance model is just one option amongst others
- Many ways of storing polymorphic objects
  + As always, space/time tradeoff
- Vtables can be inlined (measure!)
- Type erasure is tedious to do manually

====

### The Dyno library is available

https://github.com/ldionne/dyno

====

### Useful links and related material

- Sean Parent's NDC 2017 talk: <div style="font-size: 50%;">https://youtu.be/QGcVXgEVMJg</div>
- Zach Laine's CppCon 2014 talk: <div style="font-size: 50%;">https://youtu.be/0I0FD3N5cgM</div>
- Boost.TypeErasure: <div style="font-size: 50%;">http://www.boost.org/doc/libs/release/doc/html/boost_typeerasure.html</div>
- Adobe Poly: <div style="font-size: 50%;">https://stlab.adobe.com/group__poly__related.html</div>
- Eraserface: <div style="font-size: 50%;">https://github.com/badair/eraserface</div>
- liberasure: <div style="font-size: 50%;">https://github.com/atomgalaxy/liberasure</div>
- 2004 thread on interfaces: <div style="font-size: 50%;">https://goo.gl/zaBN6X</div>

====

### Thank you

https://ldionne.com

        </script>
        </section>
      </div>
    </div>

    <script src="js/google-chart.js"></script>
    <script src="js/jquery-3.2.1.min.js"></script>
    <script src="reveal/js/reveal.js"></script>
    <script src="reveal/lib/js/head.min.js"></script>

    <script>
      Reveal.initialize({
        slideNumber: 'c', // 'c/t' -> useful when authoring to know how many slides there are
        history: true,
        transition: 'none',

        dependencies: [
          { src: 'reveal/plugin/markdown/marked.js' },
          { src: 'reveal/plugin/markdown/markdown.js' },
          { src: 'reveal/plugin/notes/notes.js', async: true },
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/sampler.js' }
        ]
      });

      // Remove all DOM elements with the 'slide-hidden' class. This allows
      // statically marking slides as hidden to exclude them from the
      // presentation.
      Reveal.addEventListener('ready', function(event) {
        $(".slide-hidden").each(function(index, slide) {
          slide.remove();
        });
      });

      // Whenever the slide changes, we scan the current slide to see whether
      // there are Google charts to format, and we do it.
      google.charts.load('current', {'packages':['bar']});
      google.charts.setOnLoadCallback(function() {
        Reveal.addEventListener('slidechanged', function(event) {
          event.currentSlide.querySelectorAll('.google-chart').forEach(function(div) {
            if (!div.hasAttribute("data-chart-config")) {
              div.setAttribute("data-chart-config", div.innerHTML);
            }
            var config = JSON.parse(div.getAttribute("data-chart-config"));
            var data = google.visualization.arrayToDataTable(config.data);
            var chart = new google.charts.Bar(div);
            chart.draw(data, google.charts.Bar.convertOptions(config.options));
          });
        });
      });
    </script>
  </body>
</html>
